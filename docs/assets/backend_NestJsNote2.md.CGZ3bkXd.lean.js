import{_ as i,c as a,a2 as n,o as l}from"./chunks/framework.CAQ3h1-a.js";const o=JSON.parse('{"title":"DOCS","description":"","frontmatter":{},"headers":[],"relativePath":"backend/NestJsNote2.md","filePath":"backend/NestJsNote2.md","lastUpdated":1745490727000}'),t={name:"backend/NestJsNote2.md"};function e(h,s,p,k,r,E){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="docs" tabindex="-1">DOCS <a class="header-anchor" href="#docs" aria-label="Permalink to &quot;DOCS&quot;">​</a></h1><h2 id="netst-cli" tabindex="-1">netst cli <a class="header-anchor" href="#netst-cli" aria-label="Permalink to &quot;netst cli&quot;">​</a></h2><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @Nest/cli</span></span></code></pre></div><ul><li>nest new : 创建新项目</li><li>nest build : 构建生产环境项目</li><li>nest start : 启动项目</li><li>nest info : 查看当前项目的Nest包信息</li><li>nest add : 添加官方插件或第三方模块</li><li>nest generate : 生成模块、控制器、服务、DTO、装饰器等</li></ul><h2 id="创建项目" tabindex="-1">创建项目 <a class="header-anchor" href="#创建项目" aria-label="Permalink to &quot;创建项目&quot;">​</a></h2><p>nest new 创建项目，根据提示输入项目名称，采用的包管理器即可。</p><p>启动项目: npm run start 或者 npm run start:dev 两者区别是热更新有无。</p><p>nestjs 是MVC架构，其内置了命令可以帮助快速生成controller、service、module等文件。</p><p>nest generate controller [name] 生成controller文件 nest generate service [name] 生成service文件 nest generate module [name] 生成module文件 当然上诉命令也有间歇版本： nest g co [name] 生成controller文件 nest g s [name] 生成service文件 nest g mo [name] 生成module文件</p><p>最后，如果还是觉得麻烦，可以直接使用 nest g resource [name] 生成一个标准的CRUD模板模块，包括controller、service、DTO、module等。</p><h2 id="mvc架构" tabindex="-1">MVC架构 <a class="header-anchor" href="#mvc架构" aria-label="Permalink to &quot;MVC架构&quot;">​</a></h2><p>MVC架构是Model-View-Controller的缩写，是一种软件设计模式。它将一个复杂的软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p><ul><li>模型（Model）：模型主要负责数据的获取、存储、验证及数据库操作等。</li><li>Controlle：控制器主要负责处理用户的请求，调度Service服务，及进行API的路由管理。</li><li>View：视图主要负责数据的呈现，负责将模型数据呈现给用户。在现代Web开发中，现在这一层主要拆分给前端去做处理，即现在的后端仅需对Controller管理好API路由及业务逻辑和Module管理好数据库的工作。</li></ul><h2 id="跨域问题" tabindex="-1">跨域问题 <a class="header-anchor" href="#跨域问题" aria-label="Permalink to &quot;跨域问题&quot;">​</a></h2><h3 id="后端解决跨域问题" tabindex="-1">后端解决跨域问题 <a class="header-anchor" href="#后端解决跨域问题" aria-label="Permalink to &quot;后端解决跨域问题&quot;">​</a></h3><p>在nest.js中，我们可以通过在main.ts文件中启用CROS即可解决跨域问题。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">enableCors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="前端解决跨域问题" tabindex="-1">前端解决跨域问题 <a class="header-anchor" href="#前端解决跨域问题" aria-label="Permalink to &quot;前端解决跨域问题&quot;">​</a></h3><p>我们可以通过vite的server.proxy来解决跨域问题。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vite.config.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { defineConfig } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vite&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@vitejs/plugin-vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// https://vite.dev/config/</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  server: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    proxy: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 前端请求url直接使用&#39;/api&#39;来代替&#39;http://localhost:3000&#39;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;/api&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://localhost:3000&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        changeOrigin: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        rewrite</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">api</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="aop架构理念" tabindex="-1">AOP架构理念 <a class="header-anchor" href="#aop架构理念" aria-label="Permalink to &quot;AOP架构理念&quot;">​</a></h2><p>AOP是为了解决传统面向对象编程中的问题，比如代码重复和业务逻辑混乱的问题。 举个例子: 当我想在一个controller中打印日志，那么我应该在对应的controller中添加打印日志的代码。但是等待后续继续开发的时候，我还想将另一个controller也打印日志。那么此时我还需要继续重复编写打印日志的代码待这个controler中。而且以后要是想去除打印日志的代码，还需要多次去删除。这样无论在管理还是开发上都十分不方便。 那么此时AOP面向切面编程的思想就提出来了，即在进入controller层前，先经过一层其他的逻辑层，然后再进入controller层。这样我就可以在进入到某个controller层前，可以进行指定的一些操作等。 那么新增的这一层逻辑，我们可以类似的继续添加多几层，那么这个过程其实就是面向切面的编程思想。</p><p>传统的MVC架构，一个HTTP的请求通常为:</p><p>Http --&gt; Controller --&gt; Service --&gt; Database</p><p>在MVC架构基础上添加AOP设计思想：</p><p>Http --&gt; AOP --&gt; Controller --&gt; AOP --&gt; Service --&gt; AOP --&gt; Database</p><p>TIPS: 这里的AOP可以是任何一个不同的逻辑处理。例如日志打印、权限校验、缓存、事务等。</p><p>那么在Nestjs中，AOP切面主要有:</p><ol><li>Middleware: 中间件</li><li>Guards: 守卫</li><li>Interceptors: 拦截器</li><li>Pipe: 管道</li><li>Filter: 过滤器</li></ol><p>在Nest框架中，客户端发出的请求会经历一个分层处理过程：首先由控制器(Controller)接收请求，然后传递给服务层(Service)，接着服务层可能会调用仓库层(Repository)进行数据操作，最终将处理结果返回给客户端。这一流程正是Nest分层架构的典型体现。</p><h2 id="ioc理念" tabindex="-1">IoC理念 <a class="header-anchor" href="#ioc理念" aria-label="Permalink to &quot;IoC理念&quot;">​</a></h2><p>IoC是Inversion of Control的缩写，即控制反转。当我想要访问一个Service的时候，我通常需要先new这个Service，然后调用其方法。但是每一次请求都需要new一个Service，这无疑是十分浪费资源的。而且就算写成一个单例模式，当我想要将这个controller的Service更换为其他的Service时，我还需要修改controller的代码。这样耦合性很高。那么IoC的思想就是，我们不需要new这个Service，而是默认通过类似函数参数来传过来了，我们直接使用即可。这样当我们更换Service时，只需要传另一个Service的实例过去即可。这样耦合性就降低了。</p><p>那么在nestjs中，它把我们new一个Service的操作都拿去了，即我们不需要自己手动去管理Service，我们只需要在构造函数中注入Service即可，nestjs已经帮我们做好了这个Service的实例化工作。我们需要用的时候直接类似函数参数来声明即可使用了。</p><h2 id="nestjs-常用装饰器" tabindex="-1">NestJs 常用装饰器 <a class="header-anchor" href="#nestjs-常用装饰器" aria-label="Permalink to &quot;NestJs 常用装饰器&quot;">​</a></h2><ul><li>@Controller: 控制器装饰器，用于标识一个类是一个控制器。还可以设置路由路径前缀来管理该路由。</li><li>@Injectable: 注入器装饰器，用于标识一个类是一个可注入的类。可以被其他对象进行依赖注入。</li><li>@Module: 模块装饰器，用于标识一个类是一个模块。可以管理控制器、提供服务等。用来划分功能模块并限制依赖注入的范围。</li><li>@UseInterceptors: 拦截器装饰器，用于标识一个类是一个拦截器。可以对请求进行拦截并对请求进行处理。</li><li>@Get, @Post, @Put, @Delete: HTTP请求装饰器，用于标识一个方法是一个HTTP请求处理方法。可以设置请求路径、请求方法、请求参数等。</li><li>@Param, @Query, @Body: 请求参数装饰器，用于标识一个方法的参数是一个请求参数。可以设置参数类型、参数名称、参数默认值等。</li></ul><h2 id="nestjs-模块" tabindex="-1">NestJs 模块 <a class="header-anchor" href="#nestjs-模块" aria-label="Permalink to &quot;NestJs 模块&quot;">​</a></h2><p>在NestJs项目当中，我们通常使用 nest g resourcce [name] 命令来生成一个标准的CRUD模板模块，包括controller、service、DTO、module等。</p><p>通过命令会生成以下的文件:</p><ul><li>controller.ts: 控制器文件，用于处理HTTP请求。</li><li>service.ts: 服务文件，用于处理业务逻辑。</li><li>dto文件夹: 数据传输对象文件夹，用于定义请求参数和响应参数。</li><li>entity文件夹: 实体文件夹，用于定义数据库模型。</li><li>module.ts: 模块文件，用于管理控制器、服务、DTO、实体等。</li></ul><p>那么以上的文件则代表着一个完整的模块，而管理这个模块的则是module.ts文件。</p><h3 id="共享模块" tabindex="-1">共享模块 <a class="header-anchor" href="#共享模块" aria-label="Permalink to &quot;共享模块&quot;">​</a></h3><p>module.ts文件中，为本模块提供了一个装饰器 @Module()，用于标识一个类是一个模块。其内部controller对应该模块内的路由管理，而provider则是该模块对应的service服务的依赖注入(Nestjs帮我们做好了实例的管理)。此外还可以拥有imports属性，用于导入其他模块，以实现模块的组合。即当cats模块需要使用dogs模块的服务时，可以将dogs模块导入到cats模块中。这样我们就可以使用dogs模块中module文件中exports出去的对象了。那么这个exports出去的对象模块就叫做<strong>共享模块。</strong></p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// cats.module.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Module } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CatsService } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./cats.service&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CatsController } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./cats.controller&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  controllers: [CatsController],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  providers: [CatsService],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  exports: [CatsService], </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里导出了CatsService和CatsController，那么其他模块进行import后可以使用这两个对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CatsModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }</span></span></code></pre></div><h3 id="全局模块" tabindex="-1">全局模块 <a class="header-anchor" href="#全局模块" aria-label="Permalink to &quot;全局模块&quot;">​</a></h3><p>全局模块主要是通过 @Global() 装饰器来标识一个模块为全局模块。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// cats.module.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Module } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CatsService } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./cats.service&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CatsController } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./cats.controller&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Global</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  controllers: [CatsController],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  providers: [CatsService],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  exports: [CatsService], </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里还需要导出，但是其他模块不用再进行import了, 直接使用即可</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CatsModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }</span></span></code></pre></div><h3 id="动态模块" tabindex="-1">动态模块 <a class="header-anchor" href="#动态模块" aria-label="Permalink to &quot;动态模块&quot;">​</a></h3><p>刚开始学习的时候，可以先不做了解，等待后续集成的第三方服务再进行详细的了解。因为后续动态模块的使用非常频繁。</p><h2 id="nestjs-中间件" tabindex="-1">NestJs 中间件 <a class="header-anchor" href="#nestjs-中间件" aria-label="Permalink to &quot;NestJs 中间件&quot;">​</a></h2><p>NestJs的中间件是在路由处理程序<strong>之前</strong>调用的函数，中间件函数可以访问请求和响应对象。它可以执行以下操作：</p><ul><li>执行任何代码</li><li>对请求和响应对象进行更改</li><li>结束请求-响应周期</li><li>调用堆栈中的下一个中间件函数</li><li>如果当前中间件函数没有结束请求-响应周期，就必须调用 next() 方法将控制权传递给下一个中间件函数。否则请求将被挂起。</li></ul><p>NestJs中间件可以通过 nest generate middleware [name] 命令来生成一个中间件文件。</p><p>那么如何使用这个中间件呢? 我们可以在模块内的module文件中，对导出的Module进行重写并实现configure()方法。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { MiddlewareConsumer, Module, NestModule } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CatsService } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./cats.service&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CatsController } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./cats.controller&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { LoggerMiddleware } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;src/logger/logger.middleware&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  controllers: [CatsController],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  providers: [CatsService],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  exports: [CatsService]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CatsModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NestModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  configure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">consumer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MiddlewareConsumer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consumer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(LoggerMiddleware).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forRoutes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;cats&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="中间件调用service" tabindex="-1">中间件调用Service <a class="header-anchor" href="#中间件调用service" aria-label="Permalink to &quot;中间件调用Service&quot;">​</a></h3><p>在中间件中，不仅可以用于处理Http请求和响应，还可以能够实现依赖注入，调用Service层的业务逻辑。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Inject, Injectable, NestMiddleware } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CatsService } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;src/cats/cats.service&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Injectable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LoggerMiddleware</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NestMiddleware</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 注入catsService 这里的Service 不需要在module中进行exports</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CatsService)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> catsService</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CatsService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;中间件 before&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;中间件执行过程 ... &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.catsService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;中间件 after&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,57)]))}const g=i(t,[["render",e]]);export{o as __pageData,g as default};
