
#  面试经典150题计划

## leetcode 88.合并两个有序数组

Leetcode地址: [合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)

### 题目大意

给定两个有序且是升序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 nums1 成为一个有序的升序数组。

#### 解法1 - 暴力解法

直接将 nums2 合并到 nums1 中，然后排序。

```cpp
void merge(vecoter<int> &nums1, int m, vector<int> &nums2, int n)
{
    for (int i = 0; i <= n; i ++)
    {
        nums1[m + i] = nums2[i];
    }
    sort(nums1.begin(), nums1.end());
    return ;
}
```

#### 解法2 - 双指针解法

双指针分别指向 nums1 和 nums2 的末尾，判断 nums1 和 nums2 元素，如果是大的则将这个大的元素放在 nums1 的末尾并且将这个大的元素的指针往前走。重复这个过程，直到两个指针都走到头。另外需要进行边界处理，就是当 nums1 或者 nums2 某一个为空的时候，就将另一个数组的元素全部放入nums1。

```cpp
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int i = m - 1, j = n - 1, k = m + n - 1;
    int cur;
    while (i >= 0 || j >= 0) {
        if (i == -1) {
            cur = nums2[j--];
        } else if (j == -1) {
            cur = nums1[i--];
        } else if (nums1[i] > nums2[j]) {
            cur = nums1[i--];
        } else {
            cur = nums2[j--];
        }
        nums1[k --] = cur;
    }
    return ;
}
```

## leetcode 27.移除元素

### 题目大意

给定一个数组 nums 和一个值 val，移除数组中所有等于 val 的元素，并返回移除后数组的新长度。有点像 c++ stl 中的 erase 函数。

### 解法1 - 双指针算法

一个指针负责遍历数组，另一个指针用作符合要求的元素的移动并赋值。ß

```cpp
int removeElement(vector<int>& nums, int val)
{
    int k = 0;
    for (int i = 0; i < nums.size(); i ++)
    {
        if (nums[i] != val) {
            nums[k ++] = nums[i];
        }
    }
    return k;
}
```

### 解法2 - 快慢指针算法

快指针负责遍历并检查元素是否符合要求，慢指针负责在符合要求的情况下进行移动并将快指针的值赋值到慢指针指向的位置上。

```cpp
int removeElement(vector<int>& nums, int val)
{
    int slow = 0, fast = 0;
    while (fast < nums.size())
    {
        if (nums[fast] != val) {
            nums[slow ++] = nums[fast]; // 当元素不为val时，将其放入慢指针指向的位置
        }
        fast ++;
    }
    return slow;
}
```

## leetcode 26.删除排序数组中的重复项

### 题目大意

给定一个排序数组 nums，删除重复项，使得每个元素只出现一次，返回新的数组长度。

### 解法1 - 哈希表

开一个哈希表，然后遍历数组，查找当前元素在哈希表内的值，如果大于1则不进行加入答案操作，并将答案个数++

```cpp
#include <unordered_map>

int removeDuplicates(vector<int>& nums)
{
    int len = nums.size();
    if (!len) return 0;
    int k = 0;
    unordered_map<int, int> heap;
    for (int i = 0; i < len; i ++)
    {
        heap[nums[i]] ++;
        if (heap[nums[i]] <= 1) {
            nums[k ++] = nums[i];
        }
    }
    return k;
}
```

### 解法2 - 快慢指针

快指针与慢指针开始都指向第一个元素，然后快指针一路往前遍历，当快指针指向与其前一个元素不相等时，则赋值在慢指针指向的位置上，慢指针并往前走一步。如果快指针与其前一个元素相等时，则慢指针不作处理，快指针继续往前走。重复这个过程。

```cpp
int removeDuplicates(vector<int>& nums)
{
    int len = nums.size();
    if (!len) return 0;
    int slow = 1, fast = 1;
    while (fast < len)
    {
        if (nums[fast] != nums[fast - 1]) {
            nums[slow ++] = nums[fast];
        }
        fast ++;
    }
    return slow;
}
```

## leetcode 80. 删除有序数组中的重复项 II

### 题目大意

给定一个有序数组 nums，删除重复项，使得每个元素只出现两次，返回新的数组长度。

### 解法1 - 哈希表

跟上面一题一样，不过将判断哈希表内元素个数的条件改为大于2即可。此外还要注意当nums数组长度小于等于2时，直接返回数组长度即可不用多做处理。

```cpp
#include <unordered_map>

int removeDuplicates(vector<int>& nums)
{
    int len = nums.size();
    if (len <= 2) return len;
    int k = 0;
    unordered_map<int, int> heap;
    for (int i = 0; i < len; i ++) {
        heap[nums[i]] ++;
        if (heap[nums[i]] <= 2) {
            nums[k ++] = nums[i];
        }
    }
    return k;
}
```

### 解法2 - 快慢指针

首先快慢指针开始指向数组下标为2的位置，因为数组小于等于2的时候直接返回即可不用多做处理，故开始直接指向下标为2位置开始。
接着当快指针指向位置与慢指针指向位置不相等时，则赋值在慢指针指向的位置上，慢指针并往前走一步。如果快指针指向位置与慢指针指向位置相等时，则慢指针不作处理，快指针继续往前走。重复这个过程。

```cpp
int removeDuplicates(vector<int>& nums)
{
    int len = nums.size();
    if (len <= 2) return len;
    int slow = 2, fast = 2;
    while (fast < len)
    {
        if (nums[fast] != nums[slow - 2]) {
            nums[slow ++] = nums[fast];
        }
        fast ++;
    }
    return slow;
}
```
